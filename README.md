# My-Projects

The java code is my implementation of several solutions for job-shop scheduling problem with the use of evolutionary algorithms. It was prepared for assessment of Computational Intelligence module (yr4) - the purpose of the project was to prepare a report with references to literature about JSSP and previous implementations of solutions to this problem. The code was not a part of the mark, although the solutions had to be presented. 

The Project contains several classes. The solutions for JSSP were implemented by taking advantage of Java object-orientation concepts, inheritance and polymorphism – each solution is implemented as a separated class that inherits from an appropriate abstract class.
Solution.java is an abstract class that implements methods shared by all the Solution objects. The methods shared are:
Two classes inherit from Solution class: MachineListRepSolution which implements methods used by machine-based representation solutions and OperationListRepSolution which implements methods used by operation-based representation solutions.

Machine-based solutions are implemented in classes Solution001 and Solution002. They inherit all the methods from MachineListRepSolution. The solutions differ by the number of crossover points which is set in the method selectCrossoverPoints implemented in Solution class and used by Solution001 and Solution002 in the method createNewSolutions, thus the classes implement their own createNewSolutions methods. The number of crossover point is determined by the methods boolean parameter – if it set to true only one crossover point is selected, otherwise the methods generates 2 or 3 crossover points. Solution001 uses 1 crossover point, and Solution002 used multiple crossover points.

Operation-based solutions are implemented in classes Solution003 and Solution004. They also differ by the number of crossover points and implement their own createNewSolutions methods but they also differ by the way of translating chromosomes into solutions, that is by scheduling operations to machines, which is implemented in the method turnChromosomeIntoSolution. 

Solution003 uses one crossover point. The operations in this solution are scheduled by appending each operation to the end of the sequence of operations scheduled on the machine with consideration of the machine the operation should be scheduled on. The operation id is indicated by the order of occurrence in the chromosome.

Solution004 uses multiple crossover points. The operations are scheduled with consideration of machines being idle between operations – if the machine is idle there is a time slot where another operation can be scheduled if the previous operation of the same job ends early enough and if the machine is idle before starting the next operation for the same amount of time as the operation to be scheduled duration. If the operation cannot be scheduled in a slot when machine is idle, it is appended to the schedule after the last scheduled operation on the machine as in the Solution003.

The schedule in this algorithm (Solution004) is represented as an arraylist of arraylist of integers – each machine is represented as an arraylist of integers and assigning an operation takes place by adding integers of the same value as the job id of the operation being scheduled and the number of the integers added is indicated by the operation’s duration. Every time an operation is scheduled an end-point of the job being scheduled is updated as well as the number of operations scheduled so far for each job – this allows for scheduling operation at the right point of time. Each integer in the arraylist representing a machine represents a time-unit, therefore if the machine is idle an appropriate number of integers (-1 in this case) is assigned to represent ‘idling’ state of the machine.

The solutions are run from RunSolutions class which contains main method. Solutions objects are created by taking advantage of polymorphism. Depending on which solution is about to be used to solve JSSP, the appropriate object is created in the main method.

RunSolutions initializes population and runs the loop where solutions work by creating new chromosomes within each iteration. After the loop stops running – the population is evaluated in terms of the fitness of the solutions it contains and the minimum fitness (that is the best fitness) in the population is sent to output.
